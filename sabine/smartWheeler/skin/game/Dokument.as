package{	import flash.display.MovieClip;	import flash.display.Loader;	import flash.display.Sprite;	import flash.utils.*;		import flash.events.TimerEvent;	import flash.events.MouseEvent;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.ui.MouseCursor;	import flash.ui.Keyboard;	import flash.ui.Keyboard;	import flash.text.TextField;	import flash.text.TextFormat;	import flash.text.TextFormatAlign;	import flash.net.URLLoader;	import flash.net.URLLoaderDataFormat;	import flash.net.URLVariables;	import flash.net.URLRequest;	import flash.net.URLRequestMethod;	import flash.net.sendToURL;	import flash.net.navigateToURL;	import flash.text.Font;	public class Dokument extends MovieClip {		var spielfeldWidth:uint = 700;		var spielfeldHeight:uint = 525;		var pfad:String = '';				var game:Boolean = false;		var zoomen:Boolean = false;		var gameOver:Boolean = false;				var level:uint = 1;						//welcher Level		var levelGesamt:uint = 3;				var font:Font;		var textFormat:TextFormat;		var inputFormat:TextFormat;		var ausgabeFormat:TextFormat		var punkte_txt:TextField;				var nameSpieler:String;				var punkteSpieler:int;		var lebenAktuell:int;		var elementeZeitAktuell:Number;				var startScreen:StartScreen;		var endeScreen:EndeScreen;		var quad:Quad;		var zeitAnzeige:ZeitAnzeige;		var textAusgabe:Anzeige;		var lebenContainer:Sprite;		var varLader:URLLoader;				var elementeTimer:Timer;							var startZeitTimer:Number;		var kampagneElement:Boolean = false;		var kampagneElementDauer:Number = 5000;				/* variablen, die aus db geladen werden */		var kampagne:int = 0;					//0 für Standart, 1...kampagne1, 2...kampagne2		var lebenSpieler:int = 5;		var quadSpeed:Number = 10;		var levelZeit:Number = 10000;			//wie lange Zeit für Level		var elementeZeit:Number = 900;				public function Dokument() {			/* Kampagne bestimmen */			dbAuslesen();		}//ende Konstruktor Dokument				function dbAuslesen(){		/* schickt Request an PHP, ruft variablenGeladen auf, wenn Daten fertig geladen sind */			varLader = new URLLoader();				varLader.dataFormat = URLLoaderDataFormat.VARIABLES;				varLader.addEventListener(Event.COMPLETE, variablenGeladen);			varLader.load( new URLRequest(pfad + 'auslesen.php') );		}//ende Kampagne auslesen				function variablenGeladen(evt:Event){		/* speichert Antwort in Variable; aufgerufen wenn Daten von PHP geladen sind */			var daten:URLVariables = varLader.data;				kampagne = parseInt(daten.kampagne);				lebenSpieler = parseInt(daten.leben);				elementeZeit = Number(daten.interval);				levelZeit = Number(daten.levelTime);				quadSpeed = Number(daten.sideSpeed);						varLader.removeEventListener(Event.COMPLETE, variablenGeladen);						initGame();		}//ende variablenGeladen				function initGame(){		/* wird aufgerufen, sobald die Kampagne geladen wurde */			/* Textformat festlegen */			textFormat = new TextFormat();				if(kampagne == 1){					font = new Tahoma();					textFormat.color = 0xF59A26;					textFormat.size = 30;						textFormat.bold = true;				//KAMPAGNE 2 : green				}else if(kampagne == 2){					font = new LucidaGrande();						textFormat.color = 0x697f69;						textFormat.size = 32;							textFormat.bold = true;				//STANDART				}else{					font = new Arial();					textFormat.color = 0x361601;					textFormat.size = 30;						textFormat.bold = false;				}				textFormat.align = TextFormatAlign.LEFT;				textFormat.font = font.fontName;						/* Textformat für Textfeld festlegen */			inputFormat = new TextFormat();				// KAMPAGNE 1: street				if(kampagne == 1){					font = new Tahoma();					inputFormat.color = 0x26365C;					inputFormat.size = 18;					//KAMPAGNE 2 : green				}else if(kampagne == 2){					font = new Tahoma();					inputFormat.color = 0x697f69;					inputFormat.size = 18;					//STANDART				}else{					font = new Arial();					inputFormat.color = 0x000000;					inputFormat.size = 18;					}				inputFormat.align = TextFormatAlign.LEFT;				inputFormat.font = font.fontName;								/* Textformat für Ausgabe festlegen */			ausgabeFormat = new TextFormat();				//KAMPAGNE 1: street				if(kampagne == 1){					font = new Tahoma();										ausgabeFormat.color = 0xffffff;					ausgabeFormat.bold = true;					ausgabeFormat.size = 20;				//KAMPAGNE 2: green				}else if(kampagne == 2){					font = new Tahoma();										ausgabeFormat.color = 0x002D5C;					ausgabeFormat.bold = true;					ausgabeFormat.size = 18;					//STANDART				}else{					font = new Arial();					ausgabeFormat.color = 0x742F09;					ausgabeFormat.bold = true;					ausgabeFormat.size = 18;					}				ausgabeFormat.font = font.fontName;				ausgabeFormat.align = TextFormatAlign.LEFT;						/* startscreen einblenden */			startScreen = new StartScreen();			addChild(startScreen);		}//ende initGame				function gameMode(){			/*wird von der ScartScreen-Klasse aus aufgerufen, wenn Name korrekt eingegeben und Button gedrückt */			/* Werte initialisieren */			lebenAktuell = lebenSpieler;			elementeZeitAktuell = elementeZeit;			gameOver = false;			game = false;			zoomen = false;			punkteSpieler = 0;			level = 1;						/* Leben anzeige bilden */			lebenContainer = new Sprite();				/* leben im Anzeigecontainer erzeugen */				for (var i:int = 1; i <= lebenAktuell; i ++){					var leben:Leben = new Leben();						leben.x = spielfeldWidth - (leben.width/2) * i ;						leben.y = (spielfeldHeight - leben.height/2);					lebenContainer.addChild(leben);				}						/* Spieler bilden */			quad = new Quad();						/* Zeitanzeige bilden */			zeitAnzeige = new ZeitAnzeige();						/* Textfeld für Punkte bilden */			punkte_txt = new TextField();				textFormat.align = TextFormatAlign.LEFT;				punkte_txt.defaultTextFormat = textFormat;				punkte_txt.x = 20;				punkte_txt.y = 20;				punkte_txt.width = 300;				punkte_txt.text = String('Punkte: '+0);							/* textAnzeige bilden */			textAusgabe = new Anzeige();						/* Level erstellen */			createLevel();		}//ende gameMode()				function createLevel(){			/* erzeugt akuellen Level */						/* Timer für das Erstellen der Elemente setzten */			elementeZeitAktuell = elementeZeitAktuell - 100 * (level -1);			/* wie schnell kommen Elemente und Hindernisse; Level berücksichtigt */			elementeTimer = new Timer(elementeZeitAktuell);			elementeTimer.addEventListener(TimerEvent.TIMER, createElements);						/* Hintergrundbild laden und an den bgContainer anfügen */						var varLoader:URLLoader = new URLLoader();			var varObj:URLVariables = varLoader.data;			var bgPic:Loader = new Loader();				bgPic.load( new URLRequest( pfad + 'bg/design_'+kampagne+'/level_'+level+'.jpg') );			addChild(bgPic);						/* LebenAnzeige einblenden */			addChild(lebenContainer);						/* Quad einblenden */			addChild(quad);						/* Textfeld für Punkte einblenden */			addChild(punkte_txt);						/* zeitAnzeige einblenden */			addChild(zeitAnzeige);			zeitAnzeige.zeitAnzeige_txt.text = String('0,000'); 						/* TextAnzeige hinzufügen und Ausgabe aufrufen*/			addChild(textAusgabe);			textAusgabe.textAusgeben('LEVEL '+level);			/* Key-Event zum starten */			stage.addEventListener(KeyboardEvent.KEY_DOWN, tasteRunter);						/* Focus auf die Tastertur legen */			stage.focus = stage;				}//ende createLevel()				function tasteRunter(evt:KeyboardEvent){			if(evt.keyCode == Keyboard.UP && game == false){ 		//wird einmalig ausgelöst (nur wenn game false)				startGame();				stage.removeEventListener(KeyboardEvent.KEY_DOWN, tasteRunter);			}		}//ende tasteRunter				function startGame(){		//wird aufgerufen wenn beliebige Taste gedrückt wird			/* wird zu Beginn 1x ausgführt (wenn game noch nicht aktiv und Start-Taste gedrückt)*/			if(game === false && gameOver === false){				/* Textanzeige löschen und entfernen */				textAusgabe.clearText();				removeChild(textAusgabe);								/* spiel aktiv setzten */				game = true;				zoomen = true;								/* startet Timer und zeitAnzeige */				if(level == 1){ zeitAnzeige.begin(); }				else{ zeitAnzeige.pauseEnde(); }								elementeTimer.start();				addEventListener(Event.ENTER_FRAME, aktualisiereZeit);								/* spiel startet sofort (nicht erst nach erstem Timer durchlauf) */				createElements();			}		}//ende startGame			function createElements(evt:TimerEvent = null){		/* beinhaltet Logik zum Erstellen der Hindernisse und Elemente  */			/* nur wenn spiel aktiv */			if(game === true && gameOver === false){				/* Zufallswert wie viele Hindernisse erstellt werden; von level abhängig */				var anzahlHindernisse:uint;				anzahlHindernisse = level;				if(Math.random() > 0.75){			//in 1/4 der Fälle weicht die Anzahl der Hindernisse von dem Level ab					if(Math.ceil(Math.random()*2) == 1){ anzahlHindernisse = level - 1; }					else{ anzahlHindernisse = level + 1; }				}				 				var bahnArray:Array = new Array();		//enthält die Positionen der bislang erstellten Hindernisse einer Reihe				/* ruft die Generation der Hindernisse auf */				for (var i:uint = 0; i < anzahlHindernisse; i++){ 					/* Zufallswert auf welcher Bahn das Hindernis kommt, wird in bahnArray gespeichert */					var bahn:uint = Math.ceil(Math.random()*4);										/* prüfen ob bahn bereits belegt */					var wertOK:uint = 0;					for (var index in bahnArray){						if(bahn == bahnArray[index]){ wertOK ++; }					}					if(wertOK == 0){		//wenn Position noch nicht belegt						/* speichere Position ins Array */						bahnArray[i]=bahn;												/* Zufallswert welche Art Hindernis verwendet wird, erstellt und blendet ein */						var welchesHindernis:Number = Math.floor(Math.random()*3);												/* erstelle Hindernis nach Kampagne */						hindernisNachKampagne(bahn, welchesHindernis);					}				}								erstelleElemente(bahnArray);								}		}//ende createElements				function hindernisNachKampagne(bahn:uint, art:Number){			/* KAMPAGNE1: street*/			var einHindernis:Hindernis;			if(kampagne == 1){				if(art == 0) { einHindernis = new Kanal(); }				else if(art == 1){ einHindernis = new Kiste(); }				else{ einHindernis = new Absperrung(); }						/* KAMPAGNE2: green */			}else if(kampagne == 2){								//kampagne2				if(art == 0) { einHindernis = new Pilze(); }				else if(art == 1){ einHindernis = new Wurzel(); }				else{ einHindernis = new Baum(); }						/* STANDART */			}else{												//standart				if(art == 0) { einHindernis = new Schlange(); }				else if(art == 1){ einHindernis = new Kaktus(); }				else{ einHindernis = new Fels();}			}			einHindernis.bahn = bahn;			addChild(einHindernis);		}//ende hindernisNachKampagne				function erstelleElemente(bahnArray:Array){		/* erstellt die Elemente Coins und Sterne */			/* Anzahl an Elementen variiert zwischen 0 und 2, wobei mit einer Wahrscheinlichkeit von 0.5 1 Element erstellt wird*/ 			var anzahlElemente = 1;			if(Math.random() < 0.5){				if(Math.ceil(Math.random()*2) == 1){ anzahlElemente --; }				else{ anzahlElemente ++; }			}			/* für jedes Element wird eine X-Position gesucht */			for(var i:uint = 0; i < anzahlElemente; i++){				var position:Number = findePosition(bahnArray);				var einElement:Rotate;								/* KAMPAGNE 1: Tacho erstellen */				if(kampagne == 1 && kampagneElement == false && (Math.random()*5 < 1)  ){					einElement = new Tacho();					kampagneElement = true;				}else 								/* KAMPAGNE 2: Fahrzeug wird kleiner */				if( kampagne == 2 && kampagneElement == false && (Math.random()*5 < 1)  ){					einElement = new Verkleinern();					kampagneElement = true;				}else{								/* StandartElemente bilden */					var welchesElement:uint= Math.ceil(Math.random()*2);										if(welchesElement == 1){						/* bildet Stere und blendet sie ein */						einElement = new Stern();					}else{						/* bildet Coins und blendet sie ein */							einElement = new Credit();					}				}				einElement.x = position;				addChild(einElement);			}		}//ende erstelleElemente		function findePosition(bahnArray:Array){		/* berechnet x-Position für Elemente, die noch nicht von Hindernissen belegt sind*/			var zufallswert:Number = Math.random()*spielfeldWidth;			var wertOK:uint = 0;			for (var index in bahnArray){				var xWert = (spielfeldWidth)/4 * bahnArray[index] - (spielfeldWidth)/8;				if( (zufallswert > xWert - 60) && (zufallswert < xWert + 60) ){ wertOK ++; }			}			if(wertOK == 0){ return(zufallswert);}			else{ findePosition(bahnArray); }		}//ende findePosition				function setzteLeben(){				/* wird von Zoom.as aufgerufen, wenn hitCheck mit einem Hindernis ausgelöst wurde */			lebenAktuell --;						/* wenn alle Leben aufgebraucht sind*/			if(lebenAktuell <= 0){				levelEnde();		//stopt alle Timer und Anzeigen				gameEnde();			//endeScreen einblenden			}			/* löscht ein Leben aus der Anzeige */			lebenContainer.removeChild(lebenContainer.getChildAt(lebenAktuell));		}//ende setzteLeben				function setztePunkte(element){			//wird von Zoom.as aus bei hitTest mit einem Element aufgerufen			/* fügt die Punkte des Elements zu den Punkten des Spielers hinzu */			punkteSpieler += element.punkte;						/* aktualisieren der PunkteAnzeige */			punkte_txt.text = String('Punkte: '+punkteSpieler);		}//ende setztePunkte				function verlangsamen(){			//halb so schnell wie die vorangehende Geschwindigkeit			var neuesInterval:Number = elementeZeitAktuell * 2;					elementeTimer.delay = neuesInterval;			startZeitTimer = getTimer();			addEventListener(Event.ENTER_FRAME, pruefeTimer);		}//ende verlangsamen				function verkleinern(){			// quad verkleinern			quad.width = quad.width * 2/3;			quad.height = quad.height * 2/3;			startZeitTimer = getTimer();			addEventListener(Event.ENTER_FRAME, pruefeTimer);		}//ende verkleinern						function pruefeTimer(evt:Event){			if(getTimer() - startZeitTimer > kampagneElementDauer){				removeEventListener(Event.ENTER_FRAME, pruefeTimer);				if(kampagne == 1){					elementeTimer.delay = elementeZeitAktuell;				}				if(kampagne == 2){					quad.width = quad.width * 3/2;					quad.height = quad.height * 3/2;				}				kampagneElement = false;			}		}// ende pruefeTimer				function levelEnde(){			/* wird am Ende eines jeden Levels ausgeführt; setzt die Einstellungen zurück */			if(level == levelGesamt && lebenAktuell > 0){				/* weiter im 3. Level laufen bis alle Leben verbraucht sind */				return;			}						//zeitAnzeige.ende();			zeitAnzeige.pauseAnfang();						/* hält Spiel an */			game = false;			zoomen = false;			elementeTimer.stop();			elementeTimer.reset();			elementeTimer.removeEventListener(TimerEvent.TIMER, createElements);						/* wenn noch Level vorhanden sind -> nächster Level; sonst Ende */			if(level < levelGesamt){						level ++;				createLevel();			}		}//ende levelEnde				function gameEnde(){				/* Leben sind verbraucht */			gameOver = true;						//endgültige Punkte setzten sich aus gesammelten Punkten und 1 Punkt pro sekunde zusammen			punkteSpieler += Math.ceil(zeitAnzeige.zeit);						removeEventListener(Event.ENTER_FRAME, aktualisiereZeit);			zeitAnzeige.ende();			/* Punkte Anzeige und Spieler wird entfernt */			removeChild(punkte_txt);			removeChild(quad);			removeChild(lebenContainer);			removeChild(zeitAnzeige);						/* Anzeige von EndeScreen */			endeScreen = new EndeScreen();				endeScreen.x = spielfeldWidth/2;				endeScreen.y = spielfeldHeight/2;			addChild(endeScreen);		}// ende gameEnde				function aktualisiereZeit(evt:Event){			zeitAnzeige.zeitAnzeige_txt.text = String(zeitAnzeige.fertigeZeit); 		}//ende aktualisiereZeit 				function entferneStartScreen(){			//wird von StartScreen aus aufgerufen, nachdem play gedrückt wurde			removeChild(startScreen);		}//ende entferneStartScreen				function entferneEndeScreen(){			//wird von EndeScreen aus aufgerufen, nachdem speichern gedrückt wurde			removeChild(endeScreen);		}//ende entferneEndeScreen	}}